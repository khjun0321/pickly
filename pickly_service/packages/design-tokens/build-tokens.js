#!/usr/bin/env node

/**
 * Build script for Pickly Design Tokens
 *
 * TypeScript í† í°ì„ ë‹¤ì–‘í•œ í”Œë«í¼ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
 * - JSON (ë²”ìš©)
 * - CSS (CSS ì»¤ìŠ¤í…€ ì†ì„±)
 * - SCSS (Sass ë³€ìˆ˜)
 * - Dart (Flutter ìƒìˆ˜)
 */

const fs = require('fs');
const path = require('path');

// í† í° íŒŒì¼ë“¤ì„ ë™ì ìœ¼ë¡œ importí•˜ê¸° ìœ„í•œ ì„¤ì •
const { execSync } = require('child_process');

async function main() {
  console.log('ğŸ¨ Building Pickly Design Tokens...');

  // 1. TypeScript ì»´íŒŒì¼
  console.log('ğŸ“¦ Compiling TypeScript...');
  try {
    execSync('npx tsc --outDir dist/temp --target es2020 --module commonjs src/index.ts', {
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('âŒ TypeScript compilation failed');
    process.exit(1);
  }

  // 2. ì»´íŒŒì¼ëœ í† í° ë¡œë“œ
  const tokensPath = path.join(__dirname, 'dist/temp/index.js');
  delete require.cache[require.resolve(tokensPath)];
  const { tokens } = require(tokensPath);

  // 3. ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
  const distDir = path.join(__dirname, 'dist');
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }

  // 4. JSON í˜•ì‹ìœ¼ë¡œ ì¶œë ¥
  console.log('ğŸ“„ Generating JSON tokens...');
  const jsonTokens = flattenTokens(tokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.json'),
    JSON.stringify(jsonTokens, null, 2)
  );

  // 5. CSS ì»¤ìŠ¤í…€ ì†ì„±ìœ¼ë¡œ ì¶œë ¥
  console.log('ğŸ¨ Generating CSS tokens...');
  const cssTokens = generateCSS(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.css'),
    cssTokens
  );

  // 6. SCSS ë³€ìˆ˜ë¡œ ì¶œë ¥
  console.log('ğŸ¨ Generating SCSS tokens...');
  const scssTokens = generateSCSS(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.scss'),
    scssTokens
  );

  // 7. Dart ìƒìˆ˜ë¡œ ì¶œë ¥
  console.log('ğŸ“± Generating Dart tokens...');
  const dartTokens = generateDart(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.dart'),
    dartTokens
  );

  // 8. TypeScript íƒ€ì… ì •ì˜ ë³µì‚¬
  console.log('ğŸ“ Copying TypeScript definitions...');
  fs.copyFileSync(
    path.join(__dirname, 'src/index.ts'),
    path.join(distDir, 'index.d.ts')
  );

  // 9. JavaScript ëª¨ë“ˆ ìƒì„±
  const jsModule = `
// Generated by build-tokens.js - DO NOT EDIT
const tokens = ${JSON.stringify(jsonTokens, null, 2)};

module.exports = { tokens };
module.exports.tokens = tokens;
`.trim();

  fs.writeFileSync(
    path.join(distDir, 'index.js'),
    jsModule
  );

  // 10. ì„ì‹œ íŒŒì¼ ì •ë¦¬
  fs.rmSync(path.join(distDir, 'temp'), { recursive: true, force: true });

  console.log('âœ… Design tokens built successfully!');
  console.log('ğŸ“ Output files:');
  console.log('  - dist/tokens.json (JSON)');
  console.log('  - dist/tokens.css (CSS Custom Properties)');
  console.log('  - dist/tokens.scss (Sass Variables)');
  console.log('  - dist/tokens.dart (Dart Constants)');
  console.log('  - dist/index.js (JavaScript Module)');
  console.log('  - dist/index.d.ts (TypeScript Definitions)');
}

/**
 * ì¤‘ì²©ëœ í† í° ê°ì²´ë¥¼ í‰ë©´í™”
 */
function flattenTokens(obj, prefix = '') {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}-${key}` : key;

    if (value && typeof value === 'object' && value.value !== undefined) {
      // í† í° ê°’ì´ ìˆëŠ” ê²½ìš°
      result[newKey] = resolveTokenValue(value.value, obj);
    } else if (value && typeof value === 'object') {
      // ì¤‘ì²©ëœ ê°ì²´ì¸ ê²½ìš°
      Object.assign(result, flattenTokens(value, newKey));
    }
  }

  return result;
}

/**
 * í† í° ì°¸ì¡° í•´ê²° (ì˜ˆ: "{colors.primary.500}" â†’ ì‹¤ì œ ê°’)
 */
function resolveTokenValue(value, tokens) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    const path = value.slice(1, -1).split('.');
    let resolved = tokens;

    for (const key of path) {
      resolved = resolved?.[key];
    }

    return resolved?.value || value;
  }

  return value;
}

/**
 * CSS ì»¤ìŠ¤í…€ ì†ì„± ìƒì„±
 */
function generateCSS(tokens) {
  const header = `/**
 * Pickly Design Tokens - CSS Custom Properties
 * Generated automatically - DO NOT EDIT
 */

:root {`;

  const properties = Object.entries(tokens)
    .map(([key, value]) => `  --pickly-${key}: ${value};`)
    .join('\n');

  return `${header}\n${properties}\n}`;
}

/**
 * SCSS ë³€ìˆ˜ ìƒì„±
 */
function generateSCSS(tokens) {
  const header = `/**
 * Pickly Design Tokens - Sass Variables
 * Generated automatically - DO NOT EDIT
 */

// Sass Variables`;

  const variables = Object.entries(tokens)
    .map(([key, value]) => `$pickly-${key}: ${value};`)
    .join('\n');

  const map = `
// Sass Map
$pickly-tokens: (
${Object.entries(tokens)
  .map(([key, value]) => `  "${key}": ${value}`)
  .join(',\n')}
);`;

  return `${header}\n${variables}\n${map}`;
}

/**
 * Dart ìƒìˆ˜ ìƒì„±
 */
function generateDart(tokens) {
  const header = `/**
 * Pickly Design Tokens - Dart Constants
 * Generated automatically - DO NOT EDIT
 */

import 'package:flutter/material.dart';

class PicklyTokens {`;

  const constants = Object.entries(tokens)
    .map(([key, value]) => {
      const dartKey = toDartConstantName(key);
      const dartValue = toDartValue(value);
      return `  static const ${dartValue.type} ${dartKey} = ${dartValue.value};`;
    })
    .join('\n');

  return `${header}\n${constants}\n}`;
}

/**
 * Dart ìƒìˆ˜ëª…ìœ¼ë¡œ ë³€í™˜
 */
function toDartConstantName(key) {
  return key.replace(/-/g, '').replace(/(\d+)/g, '_$1');
}

/**
 * Dart ê°’ìœ¼ë¡œ ë³€í™˜
 */
function toDartValue(value) {
  // ìƒ‰ìƒ ê°’ ì²˜ë¦¬
  if (typeof value === 'string' && value.startsWith('#')) {
    return {
      type: 'Color',
      value: `Color(0xFF${value.slice(1)})`
    };
  }

  // px ê°’ ì²˜ë¦¬
  if (typeof value === 'string' && value.endsWith('px')) {
    return {
      type: 'double',
      value: parseFloat(value)
    };
  }

  // ê¸°ë³¸ ë¬¸ìì—´
  return {
    type: 'String',
    value: `'${value}'`
  };
}

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main };