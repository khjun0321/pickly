#!/usr/bin/env node

/**
 * Build script for Pickly Design Tokens
 *
 * TypeScript 토큰을 다양한 플랫폼 형식으로 변환
 * - JSON (범용)
 * - CSS (CSS 커스텀 속성)
 * - SCSS (Sass 변수)
 * - Dart (Flutter 상수)
 */

const fs = require('fs');
const path = require('path');

// 토큰 파일들을 동적으로 import하기 위한 설정
const { execSync } = require('child_process');

async function main() {
  console.log('🎨 Building Pickly Design Tokens...');

  // 1. TypeScript 컴파일
  console.log('📦 Compiling TypeScript...');
  try {
    execSync('npx tsc --outDir dist/temp --target es2020 --module commonjs src/index.ts', {
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('❌ TypeScript compilation failed');
    process.exit(1);
  }

  // 2. 컴파일된 토큰 로드
  const tokensPath = path.join(__dirname, 'dist/temp/index.js');
  delete require.cache[require.resolve(tokensPath)];
  const { tokens } = require(tokensPath);

  // 3. 출력 디렉토리 생성
  const distDir = path.join(__dirname, 'dist');
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }

  // 4. JSON 형식으로 출력
  console.log('📄 Generating JSON tokens...');
  const jsonTokens = flattenTokens(tokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.json'),
    JSON.stringify(jsonTokens, null, 2)
  );

  // 5. CSS 커스텀 속성으로 출력
  console.log('🎨 Generating CSS tokens...');
  const cssTokens = generateCSS(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.css'),
    cssTokens
  );

  // 6. SCSS 변수로 출력
  console.log('🎨 Generating SCSS tokens...');
  const scssTokens = generateSCSS(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.scss'),
    scssTokens
  );

  // 7. Dart 상수로 출력
  console.log('📱 Generating Dart tokens...');
  const dartTokens = generateDart(jsonTokens);
  fs.writeFileSync(
    path.join(distDir, 'tokens.dart'),
    dartTokens
  );

  // 8. TypeScript 타입 정의 복사
  console.log('📝 Copying TypeScript definitions...');
  fs.copyFileSync(
    path.join(__dirname, 'src/index.ts'),
    path.join(distDir, 'index.d.ts')
  );

  // 9. JavaScript 모듈 생성
  const jsModule = `
// Generated by build-tokens.js - DO NOT EDIT
const tokens = ${JSON.stringify(jsonTokens, null, 2)};

module.exports = { tokens };
module.exports.tokens = tokens;
`.trim();

  fs.writeFileSync(
    path.join(distDir, 'index.js'),
    jsModule
  );

  // 10. 임시 파일 정리
  fs.rmSync(path.join(distDir, 'temp'), { recursive: true, force: true });

  console.log('✅ Design tokens built successfully!');
  console.log('📁 Output files:');
  console.log('  - dist/tokens.json (JSON)');
  console.log('  - dist/tokens.css (CSS Custom Properties)');
  console.log('  - dist/tokens.scss (Sass Variables)');
  console.log('  - dist/tokens.dart (Dart Constants)');
  console.log('  - dist/index.js (JavaScript Module)');
  console.log('  - dist/index.d.ts (TypeScript Definitions)');
}

/**
 * 중첩된 토큰 객체를 평면화
 */
function flattenTokens(obj, prefix = '') {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}-${key}` : key;

    if (value && typeof value === 'object' && value.value !== undefined) {
      // 토큰 값이 있는 경우
      result[newKey] = resolveTokenValue(value.value, obj);
    } else if (value && typeof value === 'object') {
      // 중첩된 객체인 경우
      Object.assign(result, flattenTokens(value, newKey));
    }
  }

  return result;
}

/**
 * 토큰 참조 해결 (예: "{colors.primary.500}" → 실제 값)
 */
function resolveTokenValue(value, tokens) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    const path = value.slice(1, -1).split('.');
    let resolved = tokens;

    for (const key of path) {
      resolved = resolved?.[key];
    }

    return resolved?.value || value;
  }

  return value;
}

/**
 * CSS 커스텀 속성 생성
 */
function generateCSS(tokens) {
  const header = `/**
 * Pickly Design Tokens - CSS Custom Properties
 * Generated automatically - DO NOT EDIT
 */

:root {`;

  const properties = Object.entries(tokens)
    .map(([key, value]) => `  --pickly-${key}: ${value};`)
    .join('\n');

  return `${header}\n${properties}\n}`;
}

/**
 * SCSS 변수 생성
 */
function generateSCSS(tokens) {
  const header = `/**
 * Pickly Design Tokens - Sass Variables
 * Generated automatically - DO NOT EDIT
 */

// Sass Variables`;

  const variables = Object.entries(tokens)
    .map(([key, value]) => `$pickly-${key}: ${value};`)
    .join('\n');

  const map = `
// Sass Map
$pickly-tokens: (
${Object.entries(tokens)
  .map(([key, value]) => `  "${key}": ${value}`)
  .join(',\n')}
);`;

  return `${header}\n${variables}\n${map}`;
}

/**
 * Dart 상수 생성
 */
function generateDart(tokens) {
  const header = `/**
 * Pickly Design Tokens - Dart Constants
 * Generated automatically - DO NOT EDIT
 */

import 'package:flutter/material.dart';

class PicklyTokens {`;

  const constants = Object.entries(tokens)
    .map(([key, value]) => {
      const dartKey = toDartConstantName(key);
      const dartValue = toDartValue(value);
      return `  static const ${dartValue.type} ${dartKey} = ${dartValue.value};`;
    })
    .join('\n');

  return `${header}\n${constants}\n}`;
}

/**
 * Dart 상수명으로 변환
 */
function toDartConstantName(key) {
  return key.replace(/-/g, '').replace(/(\d+)/g, '_$1');
}

/**
 * Dart 값으로 변환
 */
function toDartValue(value) {
  // 색상 값 처리
  if (typeof value === 'string' && value.startsWith('#')) {
    return {
      type: 'Color',
      value: `Color(0xFF${value.slice(1)})`
    };
  }

  // px 값 처리
  if (typeof value === 'string' && value.endsWith('px')) {
    return {
      type: 'double',
      value: parseFloat(value)
    };
  }

  // 기본 문자열
  return {
    type: 'String',
    value: `'${value}'`
  };
}

// 스크립트 실행
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main };